#!/usr/bin/env python3

import sys
import os
import glob
from enum import Enum
from PyQt5 import QtWidgets, QtCore, QtGui
from PyQt5.QtCore import QObject, pyqtSignal, pyqtSlot
from PyQt5.uic import loadUi
from PyQt5.QtWidgets import *
import epics

binPath = os.path.dirname(os.path.realpath(__file__)) + os.path.sep
sharePath = binPath + "../share/imblSlits/"
sys.path.append(sharePath)

from slits import Slits, MR, Face


def is_float(str):
  try:
    float(str)
    return True
  except ValueError:
    return False


def filetitle(pth):
  return os.path.splitext(os.path.basename(pth))[0]

class BLmode(QObject):

  class Encl(Enum):
    NONE = 'OFF'
    MOD1 = '1'
    MOD2 = '2'
    MOD3 = '3'

  m1PV = epics.PV('SR08ID01PSS01:HU01B_ENABLE_STS')
  m2PV = epics.PV('SR08ID01PSS01:HU02B_ENABLE_STS')
  m3PV = epics.PV('SR08ID01PSS01:HU03B_ENABLE_STS')

  class Shut(Enum):
    NONE = 'Unknown'
    PINK = 'Pink'
    MONO = 'Mono'
    MRTS = 'Mrt'

  pinkPV = epics.PV('SR08ID01PSS01:HU01A_NOM_SHT_MOD_PERM_STS')
  mrtsPV = epics.PV('SR08ID01PSS01:HU01A_FST_SHT_MOD_PERM_STS')
  monoPV = epics.PV('SR08ID01PSS01:HU01A_MON_SHT_MOD_PERM_STS')

  updated = pyqtSignal(str)


  def __init__(self):
    super(BLmode, self).__init__()

    def onUpdate(**kw):
      self.updated.emit(str(self))
    self.m1PV.add_callback(onUpdate)
    self.m2PV.add_callback(onUpdate)
    self.m3PV.add_callback(onUpdate)
    self.pinkPV.add_callback(onUpdate)
    self.monoPV.add_callback(onUpdate)
    self.mrtsPV.add_callback(onUpdate)

  def __str__(self):
    return self.encl().value+'-'+self.shut().value


  def encl(self):
    if self.m3PV.get(timeout=0) is None or \
       self.m2PV.get(timeout=0) is None or \
       self.m1PV.get(timeout=0) is None :
      return self.Encl.NONE
    elif self.m3PV.value:
      return self.Encl.MOD3
    elif self.m2PV.value:
      return self.Encl.MOD2
    elif self.m1PV.value:
      return self.Encl.MOD1
    else:
      return self.Encl.NONE


  def shut(self):
    if self.pinkPV.get(timeout=0) is None or \
       self.monoPV.get(timeout=0) is None or \
       self.mrtsPV.get(timeout=0) is None or \
       1 != self.pinkPV.value + self.monoPV.value + self.mrtsPV.value:
      return self.Shut.NONE
    elif self.pinkPV.value:
      return self.Shut.PINK
    elif self.monoPV.value:
      return self.Shut.MONO
    elif self.mrtsPV.value:
      return self.Shut.MRTS
    else:
      return self.Shut.NONE


class MainWindow(QMainWindow):

  slitsExt = 'slits'
  blMode = BLmode()
  slitNames = {'panda': 'HHLS',
               'baby' : 'Baby bear',
               'mama' : 'Mama bear',
               'papa' : 'Papa bear'}


  def __init__(self):
    super(MainWindow, self).__init__()

    self.localDataDir   = QtCore.QStandardPaths.writableLocation(QtCore.QStandardPaths.AppDataLocation)
    self.globalDataDirs = QtCore.QStandardPaths.standardLocations(QtCore.QStandardPaths.AppDataLocation)
    os.makedirs(self.localDataDir, exist_ok=True)
    self.ui = loadUi(sharePath + 'imblSlits.ui', self)
    
    prst = self.ui.preset
    for ddir in self.globalDataDirs:
      for cfg in glob.glob(ddir + os.path.sep + '*.' + self.slitsExt):
        prst.addItem(filetitle(cfg), cfg)
        prst.setItemData(prst.count()-1, cfg, QtCore.Qt.ToolTipRole)
    prst.currentIndexChanged.connect(lambda idx: \
      prst.setToolTip(prst.itemData(idx, QtCore.Qt.ToolTipRole)))

    self.bears = {}
    self.synbts = {}
    for nslt in self.slitNames:
      self.bears[nslt] = eval('self.ui.'+nslt+'Bear')
      self.synbts[nslt] = eval('self.ui.'+nslt+'Synch')

    for nslt, desc in self.slitNames.items():
      self.bears[nslt].face.set(sharePath+nslt+'.png', desc)
      self.synbts[nslt].setText(desc)
      self.synbts[nslt].setIcon(QtGui.QIcon(sharePath+nslt+'.png'))
    self.ui.mashaBear.face.set(sharePath+'masha.png', 'Detector')
    self.ui.xrayFace.set(sharePath+'xray.png', 'Config')
    self.ui.xrayFace.setMinimumSize(self.ui.mashaBear.face.minimumSize())
    self.ui.mashaBear.visual.heightChanged.connect(
      self.ui.fakeSlitsVis.setMinimumHeight)

    tab = self.ui.tabWidget.tabBar()
    tab.setExpanding(True)
    for itab in range(0, tab.count()):
      slt = self.ui.tabWidget.widget(itab).findChild(Slits)
      if slt:
        slt.layFaceTab.layout().addWidget(slt.face)
        tab.setTabButton(itab,  QTabBar.LeftSide, slt.layFaceTab)

    self.ui.pandaBear.setDistance(14)
    self.ui.pandaBear.setMotors({MR.VP : 'SR08ID01SLW01:VPOS',
                                 MR.VS : 'SR08ID01SLW01:VOPEN',
                                 MR.LF : 'SR08ID01SLW01:RIGHT', # left/right are swapped
                                 MR.RT : 'SR08ID01SLW01:LEFT'})

    self.ui. babyBear.setDistance(20)
    self.ui. babyBear.setMotors({MR.VP : 'SR08ID01SLM12:VCENTRE',
                                 MR.VS : 'SR08ID01SLM12:VSIZE',
                                 MR.HP : 'SR08ID01SLM12:HCENTRE',
                                 MR.HS : 'SR08ID01SLM12:HSIZE'},
                                'SR08ID01SLM12:VCENTRE',
                                [(MR.LF, 'SR08ID01SLM12:IN'),
                                 (MR.RT, 'SR08ID01SLM12:OUT'),
                                 (MR.BT, 'SR08ID01SLM12:BOT'),
                                 (MR.TP, 'SR08ID01SLM12:TOP')])

    self.ui. mamaBear.setDistance(31)
    self.ui. mamaBear.setMotors({MR.VP : 'SR08ID01SLM21:Z',
                                 MR.VS : 'SR08ID01SLM21:ZGAP',
                                 MR.HP : 'SR08ID01SLM21:Y',
                                 MR.HS : 'SR08ID01SLM21:YGAP'},
                                'SR08ID01TBL21:Z')

    self.ui.papaBear.setDistance(136)
    self.ui.papaBear.setMotors(  {MR.VP : 'SR08ID01SLM03:ZCENTRE',
                                  MR.VS : 'SR08ID01SLM03:ZGAP',
                                  MR.HP : 'SR08ID01SLM03:YCENTRE',
                                  MR.HS : 'SR08ID01SLM03:YGAP'},
                                 'SR08ID01SLM03:ZCENTRE',
                                 [(MR.LF, 'SR08ID01SLM03:LEFT'),
                                  (MR.RT, 'SR08ID01SLM03:RIGHT'),
                                  'SR08ID01SLM03:ROTARYARM'])

    self.showcfg = QPushButton('', self)
    self.showcfg.clicked.connect(self.showConfig)
    self.ui.statusbar.addPermanentWidget(self.showcfg)
    self.ui.statusbar.addPermanentWidget(QWidget(), 1)
    self.showConfig(False)

    self.ui.statusbar.addPermanentWidget(QLabel('Beamline mode: ', self))
    modeLabel = QLabel(str(self.blMode), self)
    self.blMode.updated.connect(modeLabel.setText)
    self.ui.statusbar.addPermanentWidget(modeLabel)

    distances = QMenu(self)
    for nslt, desc in self.slitNames.items():
      distances.addAction(QtGui.QIcon(sharePath+nslt+'.png'),
                          desc, self.distancePicked)
    self.ui.distances.setMenu(distances)
    self.ui.distance.valueChanged.connect(self.ui.mashaBear.setDistance)

    synchs = QMenu(self)
    synchs.addAction('Seen in any', self.synchPicked)
    synchs.addAction('Seen in all', self.synchPicked)
    for nslt, desc in self.slitNames.items():
      synchs.addAction(QtGui.QIcon(sharePath+nslt+'.png'),
                       desc, self.synchPicked)
    self.ui.synchMasha.setMenu(synchs)

    self.blMode.updated.connect(self.initMasha)
    for slt in self.ui.findChildren(Slits):
      slt.changedConnection.connect(self.initMasha)
    self.blMode.updated.connect(self.updateBase)
    QtCore.QTimer.singleShot(0, self.updateBase)

    self.ui.viewTab.clicked.connect(lambda: self.uiModeSwap(True))
    self.ui.viewFam.clicked.connect(lambda: self.uiModeSwap(False))
    self.uiModeSwap(True)

    self.ui.save.clicked.connect(self.onSave)
    self.ui.load.clicked.connect(self.onLoad)

    self.ui.goWhite.clicked.connect(self.moveToBlMode)
    self.ui.goMono .clicked.connect(self.moveToBlMode)

    self.ui.mashaBear.willMoveNow.connect(self.onMashaMove)
    for slt in self.bears.values():
      self.ui.mashaBear.ui.stop.clicked.connect(slt.stop.clicked.emit)
      slt.changedConnection.connect(self.setMashaStatus)
      slt.changedMotion    .connect(self.setMashaStatus)
      slt.changedLimits    .connect(self.setMashaStatus)
    QtCore.QTimer.singleShot(0, self.setMashaStatus)


  @pyqtSlot()
  def updateBase(self):
    for slt in self.bears.values():
      slt.setBase(20 if self.blMode.shut() == BLmode.Shut.MONO else 0)


  def moveToBlMode(self):
    if self.sender() not in (self.ui.goWhite, self.ui.goMono):
      return
    for nslt in self.slitNames:
      slt = self.bears[nslt]
      if self.synbts[nslt].isChecked() and slt.baseMotor is not None:
        if self.ui.driveAbs.isChecked():
          slt.baseMotor.goUserPosition(0 if self.sender() is self.ui.goWhite else 20)
        else:
          slt.baseMotor.goRelative(-20 if self.sender() is self.ui.goWhite else 20)



  @pyqtSlot()
  def showConfig(self, toShow=None):
    tbwg = self.ui.tabWidget
    if toShow is None:
      toShow = tbwg.widget(tbwg.count()-1) is not self.ui.configTab
    self.showcfg.setText('Hide config' if toShow else 'Show config')
    if toShow:
      tbwg.addTab(self.ui.configTab, '')
      # Have to create and use this new widget as home for
      # self.ui.layXrayFaceTab instead of using it itself
      # because it is always deleted when removing tab - even if reparented
      layXrayFaceTab = QWidget()
      QVBoxLayout(layXrayFaceTab).setContentsMargins(0, 0, 0, 0)
      layXrayFaceTab.layout().addWidget(self.ui.layXrayFaceTab)
      tbwg.tabBar().setTabButton(
        tbwg.count()-1,  QTabBar.LeftSide, layXrayFaceTab)
      tbwg.setCurrentWidget(self.ui.configTab)
    else:
      self.ui.config.layout().addWidget(self.ui.layXrayFaceTab)  # to keep from delete
      tbwg.removeTab(tbwg.count()-1)
    self.configFam.setVisible(toShow)
    for i in range(0, 10):
      QApplication.processEvents()
    if not toShow and self.ui.famWidget.isVisible():
      QtCore.QTimer.singleShot(0, (lambda: self.resize(self.minimumSizeHint())))


  @pyqtSlot()
  def uiModeSwap(self, toTab):

    (self.ui.viewTab if toTab else self.ui.viewFam).setChecked(True)
    self.ui.famWidget.setVisible(not toTab)
    self.ui.tabWidget.setVisible(toTab)

    wslt = 'Tab' if toTab else 'Fam'

    eval('self.ui.masha'+wslt).layout().addWidget(self.ui.masha)
    eval('self.ui.config'+wslt).layout().addWidget(self.ui.config)
    for nslt in self.slitNames:
      eval('self.ui.'+nslt+wslt).layout().addWidget(eval('self.ui.'+nslt))
    for slt in self.ui.findChildren(Slits):
      eval('slt.layFace'+wslt).layout().addWidget(slt.face)

    self.ui.fakeSlitsVis.setVisible(not toTab)
    self.ui.layXrayFaceFam.setVisible(not toTab)
    layXF = eval('self.ui.layXrayFace'+wslt)
    layXF.layout().addWidget(self.ui.xrayFace)
    layXF.setMinimumSize(self.ui.xrayFace.minimumSize())
    QtCore.QTimer.singleShot(0, (lambda: self.resize(self.minimumSizeHint())))


  @pyqtSlot()
  def distancePicked(self):
    sndtxt = self.sender().text().replace('&', '')
    nslt = [ns for ns, desc in self.slitNames.items() if sndtxt == desc][0]
    self.ui.distance.setValue(self.bears[nslt].dist)


  @pyqtSlot()
  def synchPicked(self):
    sndtxt = self.sender().text().replace('&', '')
    posf = {}
    bearL = [self.bears[ns]
             for ns, desc in self.slitNames.items() if sndtxt == desc]
    if len(bearL):
      posf = bearL[0].posDRV()
    else:
      posS = []
      for nslt in self.slitNames:
        if self.synbts[nslt].isChecked():
          posS.append(self.bears[nslt].posDRV())
      if not len(posS):
        return
      elif 'any' in sndtxt:
        for rol in MR.LF, MR.RT, MR.TP, MR.BT:
          posf[rol] = max(pos[rol] for pos in posS)
      elif 'all' in sndtxt:
        for rol in MR.LF, MR.RT, MR.TP, MR.BT:
          posf[rol] = min(pos[rol] for pos in posS)
    self.ui.mashaBear.setPos(posf)


  @pyqtSlot()
  def initMasha(self):

    def execonmod(slt):
      if slt.isConnected:
        self.ui.distance.setValue(slt.dist)
        self.ui.mashaBear.setPos(slt.posDRV())
        self.ui.mashaBear.ui.step.setValue(slt.ui.step.value())
        self.mashainited = True

    encl = self.blMode.encl()
    if hasattr(self, 'mashainited') or encl is BLmode.Encl.NONE:
      return
    elif encl is BLmode.Encl.MOD1:
      execonmod(self.ui.babyBear)
    elif encl is BLmode.Encl.MOD2:
      execonmod(self.ui.mamaBear)
    elif encl is BLmode.Encl.MOD3:
      execonmod(self.ui.papaBear)


  @pyqtSlot(dict, dict)
  def onMashaMove(self, orig, dest):
    for nslt in self.slitNames:
      if self.synbts[nslt].isChecked():
        slt = self.bears[nslt]
        if self.ui.driveAbs.isChecked():
          slt.onMoveOrder(dest)
        else:
          sorig = slt.posRBV()
          sdest = {rol : sorig[rol] + dest[rol] - orig[rol] for rol in MR}
          slt.onMoveOrder(sdest)


  @pyqtSlot()
  def setMashaStatus(self):
    connected = True
    moving = False
    limit = False
    for slt in self.bears.values():
      connected &= slt.isConnected
      moving |= slt.isMoving
      limit |= slt.isOnLimit
    self.ui.goWhite.setEnabled(connected and not moving)
    self.ui.goMono .setEnabled(connected and not moving)
    self.ui.save   .setEnabled(connected and not moving)
    self.ui.load   .setEnabled(connected and not moving)
    self.ui.mashaBear.onStatusChange(connected, moving, limit)

  
  def _fileSaveLoad(self, fileName, forsave):
    prst = self.ui.preset
    if fileName is not None:
      return fileName
    if prst.currentData():
      if not forsave:
        return prst.currentData()
      ovwr = QMessageBox.warning(self, 'Overwrite file?',
        'The file "' + prst.currentData() + '" already exists. Do you wish to overwrite it?',
        QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
        QMessageBox.StandardButton.No)
      return prst.currentData() if ovwr == QMessageBox.StandardButton.Yes else None

    dialDir = self.fileDir if hasattr(self, 'fileDir') else self.localDataDir
    getSL = QFileDialog.getSaveFileName \
            if forsave else \
            QFileDialog.getOpenFileName            
    dialTitle = ('Save' if forsave else 'Load') + ' configuration'
    fileName = getSL(self, dialTitle, dialDir,
                     filter='Slits (*.'+self.slitsExt+');;All Files (*)')[0]

    if not fileName:
      return None
    self.fileDir = os.path.dirname(fileName)
    if -1 == prst.findData(fileName):
      prst.addItem(filetitle(fileName), fileName)
      prst.setItemData(prst.count()-1, fileName, QtCore.Qt.ToolTipRole)
      prst.setCurrentIndex(prst.count()-1)
    return fileName



  @pyqtSlot()
  def onSave(self, fileName=None):

    fileName = self._fileSaveLoad(fileName, True)
    if not fileName:
      return

    config = QtCore.QSettings(fileName, QtCore.QSettings.IniFormat)
    if config is None or not config.isWritable():
      QMessageBox.warning(self, '',
        'Failed to open and/or save configuration to\n' + fileName)
      return

    config.setValue('distance', self.ui.distance.value())
    config.setValue('tabbedui', self.ui.viewTab.isChecked())
    config.setValue('driverel', self.ui.driveRel.isChecked())

    for nslt in self.slitNames:
      if self.synbts[nslt].isChecked():
        config.beginGroup(nslt)
        slt = self.bears[nslt]

        def motcfg(mot):
          return mot.getPv() + ' ' + str(mot.getUserPosition())

        for rol, mot in slt.motors.items():
          config.setValue('MR_' + rol.name, motcfg(mot))

        if slt.baseMotor is not None and slt.baseMotor not in slt.motors.values():
          config.setValue('MR_BS', motcfg(slt.baseMotor))

        addMotors = slt.additionalMotors()
        if len(addMotors):
          config.beginWriteArray("additionalmotors", len(addMotors))
          cnt = 0
          for mot in addMotors:
            config.setArrayIndex(cnt)
            config.setValue('mot', motcfg(mot))
            cnt += 1
          config.endArray()

        config.endGroup()


  @pyqtSlot()
  def onLoad(self, fileName=None):

    fileName = self._fileSaveLoad(fileName, False)
    if not fileName:
      return

    config = QtCore.QSettings(fileName, QtCore.QSettings.IniFormat)
    if config is None or config.status():
      QMessageBox.warning(self, '',
        'Failed to open and/or load configuration from\n' + fileName)
      return

    if config.value('distance') is not None:
      self.ui.distance.setValue(float(config.value('distance')))
    if config.value('tabbedui') is not None:
      self.uiModeSwap(bool(config.value('tabbedui')))
    if config.value('driverel') is not None:
      self.showConfig(bool(config.value('driverel')))

    cfgprobs = []
    groups = config.childGroups()
    for nslt in self.slitNames:
      self.synbts[nslt].setChecked(nslt in groups)

      if nslt in groups:
        config.beginGroup(nslt)
        slt = self.bears[nslt]
        roles = (key[3:] for key in config.childKeys() if key.startswith('MR_'))

        for roln in roles:
          pv, pos = config.value('MR_'+roln).split(' ')
          rol = MR[roln] if roln in MR.__members__ else None
          prob = None

          if not is_float(pos):
            prob = 'Non-float target position \"' + pos +'\"'
          elif roln == 'BS':
            if pv != slt.baseMotor.getPv():
              prob = 'PV mismatch ' + pv + ' != ' + slt.baseMotor.getPv()
            else:
              slt.baseMotor.goUserPosition(float(pos))
              #print('PVGO' + pv + '->' + pos)
          elif rol is None:
            prob = 'MotoRole has no member ' + roln
          elif rol not in slt.motors:
            prob = 'Has no motor with role ' + roln
          elif pv != slt.motors[rol].getPv():
            prob = 'PV mismatch ' + pv + ' != ' + slt.motors[rol].getPv()
          else:
            slt.motors[rol].goUserPosition(float(pos))
            # print('PVGO ' + pv + '->' + pos)
          if prob:
            cfgprobs.append(nslt + ': ' + prob)

        config.endGroup()

    if len(cfgprobs):
      msgprobs = 'There were problems loading config file:\n'
      for prob in cfgprobs:
        msgprobs += prob + '\n'
      QMessageBox.warning(self, '', msgprobs)








app = QApplication(sys.argv)

my_mainWindow = MainWindow()
my_mainWindow.show()

sys.exit(app.exec_())
